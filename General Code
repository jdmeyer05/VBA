' General notes:
' - Always use dynamic arrays. These array subroutines that have a ByRef parameter array
'   need to reference dynamic arrays.
' - In general, using these arrays will renormalize all arrays so that LBOUND = 1
' - References required:
'       - Regular expressions: go to Tools -> References and make sure
'         Microsoft VBScript Regular Expressions 5.5 is checked.
'       - Access DB connections: go to Tools -> References and make sure
'         Microsoft Office 14.0 Access database enginer Object Library is checked.
'       - SQL server connection: go to Tools -> References and make sure
'         Microsoft ActiveX Data Objects 2.8 Library is checked.

Option Explicit

Dim InitWs As Worksheet
Dim InitCalc As XlCalculation

' ---------------------------------------------------
' Custom Error Enumeration
' ---------------------------------------------------

Enum CustomErrors
' Assign custom error numbers to custom errors in this module

' Input array is empty
    CustomErr1 = 518
' Input array has more than 2 dimensions
    CustomErr2 = 519
' Input string or string array is empty or invalid
    CustomErr3 = 520
' Input array has more than 1 dimension
    CustomErr4 = 521
' Column index exceeds the number of columns in the array
    CustomErr5 = 522
' Input range is not set
    CustomErr6 = 523
' Input array has too many dimensions
    CustomErr7 = 524
' Specified worksheet name does not exist
    CustomErr8 = 525
' Specified workbook name does not exist
    CustomErr9 = 525
    
End Enum


' ---------------------------------------------------
' Miscellaneous Subroutines
' ---------------------------------------------------

Private Sub StatusBar()
' Get the status bar to show that program is running

    Application.StatusBar = "Running..."
    DoEvents

' Display Done! for 1 second, then reset status bar
    Application.StatusBar = "Done!"
    Application.Wait (Now + TimeValue("0:00:01"))
    Application.StatusBar = False
    
End Sub


Private Sub Start()
' Initialize

Set InitWs = ActiveSheet
InitCalc = Application.Calculation

With Application
    .Calculation = xlManual
    .ScreenUpdating = False
    .StatusBar = "Running..."
End With

End Sub


Private Sub Finish()
' Cleanup
    
On Error Resume Next
    
With Application
    .Calculation = InitCalc
    '.Calculation = xlCalculationAutomatic
    .ScreenUpdating = True
    .StatusBar = False
End With

'ActiveWorkbook.Sheets(1).Activate
InitWs.Activate

End

End Sub


Private Sub LastRow()
' Find last row

Dim iLastRow As Long

iLastRow = ActiveSheet.Cells(ActiveSheet.Rows.Count, 1).End(xlUp).Row

End Sub


Private Sub LastCol()
' Find the last column

Dim iLastCol As Long

iLastCol = ActiveSheet.Cells(1, ActiveSheet.Columns.Count).End(xlToLeft).Column

End Sub


Public Sub Normal_View_All_Tabs()

Dim ws As Worksheet

For Each ws In ActiveWorkbook.Sheets
    ws.Activate
    ActiveWindow.View = xlNormalView
    ws.Range("A1").Select
    ActiveWindow.Zoom = 85
Next ws

End Sub


Public Sub Print_View_All_Tabs()

Dim ws As Worksheet

For Each ws In ActiveWorkbook.Sheets
    ws.Activate
    ActiveWindow.View = xlPageBreakPreview
    ws.Range("A1").Select
Next ws

End Sub


Private Sub Remove_Filter(ws As Worksheet)

With ws
    If (.AutoFilterMode And .FilterMode) Or .FilterMode Then
      .ShowAllData
    End If
End With

End Sub

' ---------------------------------------------------
' Error Checking Subroutines and Functions
' ---------------------------------------------------


Private Function bCentralErrorHandler(ByVal strSubName As String) As Boolean
' For errors that cannot be handled by the subroutine it's coming from.
' Logs errors to immediate window, displays error messages, and returns the
'   value of bDebugMode to the calling sub or function.
' The standard error handling section should stop execution if bDebugMode is
'   set to TRUE, and call the Finish subroutine if bDebugMode is set to FALSE.

Dim bDebugMode As Boolean
Dim lErrNum As Long

' Set the debug mode. By default, debug mode is off (false).
' DON'T FORGET TO TURN OFF DEBUG MODE WHEN THE PROJECT IS LIVE!!!
bDebugMode = False

' Store the error number before it gets cleared by "On Error Resume Next"
lErrNum = Err.Number

' Can't have errors in the error handler because the error handler can't handle its own errors.
On Error Resume Next

' Log and display error messages
Select Case lErrNum

    Case CustomErrors.CustomErr1
        Debug.Print "Error #" & lErrNum & " for " & strSubName & ": Input array is empty"
        MsgBox Prompt:=strSubName & ": Input array is empty", _
            Title:="Error Source: " & strSubName, Buttons:=vbCritical
    
    Case CustomErrors.CustomErr2
        Debug.Print "Error #" & lErrNum & " for " & strSubName & ": Input array has more than 2 dimensions"
        MsgBox Prompt:=strSubName & ": Input array has more than 2 dimensions", _
            Title:="Error Source: " & strSubName, Buttons:=vbCritical
    
    Case CustomErrors.CustomErr3
        Debug.Print "Error #" & lErrNum & " for " & strSubName & ": Input string or string array is empty or invalid"
        MsgBox Prompt:=strSubName & ": Input string or string array is empty or invalid", _
            Title:="Error Source: " & strSubName, Buttons:=vbCritical
    
    Case CustomErrors.CustomErr4
        Debug.Print "Error #" & lErrNum & " for " & strSubName & ": Input array has more than 1 dimension"
        MsgBox Prompt:=strSubName & ": Input array has more than 1 dimension", _
            Title:="Error Source: " & strSubName, Buttons:=vbCritical

    Case CustomErrors.CustomErr5
        Debug.Print "Error #" & lErrNum & " for " & strSubName & ": Column index exceeds the number of columns in the array"
        MsgBox Prompt:=strSubName & ": Column index exceeds the number of columns in the array", _
            Title:="Error Source: " & strSubName, Buttons:=vbCritical
        
    Case CustomErrors.CustomErr6
        Debug.Print "Error #" & lErrNum & " for " & strSubName & ": Input range is not set"
        MsgBox Prompt:=strSubName & ": Input range is not set", _
            Title:="Error Source: " & strSubName, Buttons:=vbCritical
        
    Case CustomErrors.CustomErr7
        Debug.Print "Error #" & lErrNum & " for " & strSubName & ": Input array has too many dimensions."
        MsgBox Prompt:=strSubName & ": Input array has too many dimensions.", _
            Title:="Error Source: " & strSubName, Buttons:=vbCritical
            
    Case CustomErrors.CustomErr8
        Debug.Print "Error #" & lErrNum & " for " & strSubName & ": The specified worksheet name does not exist."
        MsgBox Prompt:=strSubName & ": The specified worksheet name does not exist.", _
            Title:="Error Source: " & strSubName, Buttons:=vbCritical
            
    Case CustomErrors.CustomErr9
        Debug.Print "Error #" & lErrNum & " for " & strSubName & ": The specified workbook name does not exist."
        MsgBox Prompt:=strSubName & ": The specified workbook name does not exist.", _
            Title:="Error Source: " & strSubName, Buttons:=vbCritical
            
    Case -2147467259
        Debug.Print "SQL Server Connection Error. Cannot find specified server/db."
        MsgBox Prompt:=strSubName & ": SQL Server Connection Error. Cannot find specified server or database.", _
            Title:="Error Source: " & strSubName, Buttons:=vbCritical
            
    Case -2147217871
        Debug.Print "SQL Server Query Timeout. Query time is over 10 minutes."
        MsgBox Prompt:=strSubName & ": SQL Server Query Timeout. Query time is over 10 minutes.", _
            Title:="Error Source: " & strSubName, Buttons:=vbCritical
            
    Case -2147217865
        Debug.Print "Query Error. Query could not be executed as written."
        MsgBox Prompt:=strSubName & ": Query Error. Query could not be executed as written.", _
            Title:="Error Source: " & strSubName, Buttons:=vbCritical
            
    Case Else
        Debug.Print "Error #" & lErrNum & " for " & strSubName & " " & Error(lErrNum)
        MsgBox Prompt:=strSubName & " Error #" & lErrNum & ": " & Error(lErrNum), _
            Title:="Error Source: " & strSubName, Buttons:=vbCritical
        
End Select

' Return bDebugMode value
bCentralErrorHandler = bDebugMode

End Function


Private Sub Err_InvalidRange(ByVal strSubName As String, ByVal rngInput As Variant)
' Check that a valid range was passed. Exit sub if range is invalid.

On Error Resume Next

If rngInput Is Nothing Then
    Err.Raise CustomErrors.CustomErr6
End If

Exit Sub

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Sub


Private Sub Err_EmptyArray(ByVal strSubName As String, ByVal arrInput As Variant)
' Check if array is empty

Dim bArrayAllocated As Boolean

On Error Resume Next
        
If IsArray(arrInput) Then
    If Not IsError(LBound(arrInput, 1)) Then
        If LBound(arrInput, 1) <= UBound(arrInput, 1) Then
            bArrayAllocated = True
        Else
            bArrayAllocated = False
        End If
    Else
        bArrayAllocated = False
    End If
Else
    bArrayAllocated = False
End If

On Error GoTo ErrorHandler

If bArrayAllocated = False Then
    Err.Raise CustomErrors.CustomErr1
End If

Exit Sub

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Sub


Private Sub Err_DimensionCheck(ByVal strSubName As String, ByVal arrInput As Variant, ByVal iMaxDim As Integer)
' Count number of dimensions and check whether it exceeds the max number.

' REQUIRED SUBS/FUNCTIONS:
'   - iNumOfArrDim

If iNumOfArrDim(arrInput) > iMaxDim Then
    Select Case iMaxDim
        Case 1
            Err.Raise CustomErrors.CustomErr4
        Case 2
            Err.Raise CustomErrors.CustomErr2
        Case Else
            Err.Raise CustomErrors.CustomErr7
    End Select
End If

Exit Sub

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Sub


Private Sub Err_BadString(ByVal strSubName As String, ByVal strInput As String)
' Check if string is empty

On Error GoTo ErrorHandler

If strInput = "" Then
    Err.Raise CustomErrors.CustomErr3
End If

Exit Sub

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Sub


Private Sub Err_ColIndexHigh(ByVal strSubName As String, ByVal arrInput As Variant, ByVal iColIndex As Long)
' Check if the column index number is greater than the number of "columns" in the array

' REQUIRED SUBS/FUNCTIONS:
'   - iNumOfArrDim

Dim iDim As Integer

On Error GoTo ErrorHandler

iDim = iNumOfArrDim(arrInput)

If iDim = 1 Then
    Exit Sub
Else
    If iColIndex > (UBound(arrInput, 2) - LBound(arrInput, 2) + 1) Then
        Err.Raise CustomErrors.CustomErr5
    End If
End If

Exit Sub

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Sub


Private Sub Err_WorksheetExist(ByVal strSubName As String, ByVal strWorksheetName As String, Optional ByVal strWorkbookName As String = "")
' Check if the specified worksheet name exists in the specified workbook. If no workbook is specified,
' then the active workbook is used.

Dim wb As Workbook
Dim wbCheck As Workbook
Dim ws As Worksheet
Dim bWbFound As Boolean
Dim bWsFound As Boolean

On Error GoTo ErrorHandler

If strWorksheetName = "" Then
    Err.Raise CustomErrors.CustomErr3
End If

bWbFound = False
bWsFound = False

If strWorkbookName = "" Then

    For Each ws In ActiveWorkbook.Sheets
        If ws.Name = strWorksheetName Then
            bWsFound = True
        End If
    Next ws
    
Else
    For Each wb In Application.Workbooks
        If wb.Name = strWorkbookName Then
            bWbFound = True
            Set wbCheck = wb
        End If
    Next wb
    
    If bWbFound = False Then
        Err.Raise CustomErrors.CustomErr9
    End If
    
    For Each ws In wbCheck.Sheets
        If ws.Name = strWorksheetName Then
            bWsFound = True
        End If
    Next ws
End If

If bWsFound = False Then
    Err.Raise CustomErrors.CustomErr8
End If

Exit Sub

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Sub


' ---------------------------------------------------
' Useful Functions
' ---------------------------------------------------


Private Function bEmptyArray(ByVal arrInput As Variant) As Boolean
' Check if array is empty

Dim bArrayAllocated As Boolean

On Error GoTo ErrorHandler

strSubName = "bEmptyArray"

On Error Resume Next
        
If IsArray(arrInput) Then
    If Not IsError(LBound(arrInput, 1)) Then
        If LBound(arrInput, 1) <= UBound(arrInput, 1) Then
            bArrayAllocated = True
        Else
            bArrayAllocated = False
        End If
    Else
        bArrayAllocated = False
    End If
Else
    bArrayAllocated = False
End If

On Error GoTo ErrorHandler

bEmptyArray = Not bArrayAllocated

Exit Function

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Function


Private Function iNumOfArrDim(ByVal arrInput As Variant) As Integer
' Count number of dimensions

Dim strSubName
Dim iDim As Integer
Dim lUbound As Long

On Error GoTo ErrorHandler

strSubName = "iNumOfArrDim"

On Error Resume Next

Do
    iDim = iDim + 1
    lUbound = UBound(arrInput, iDim)
Loop Until Err.Number <> 0

iNumOfArrDim = iDim - 1
Err.Clear

On Error GoTo ErrorHandler

Exit Function

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Function


Private Function strCleanStr(ByRef strInput As String) As String
' Use regex to remove special charaters from the string.
' If this doesn't work, go to Tools -> References and make sure
' Microsoft VBScript Regular Expressions 5.5 is checked.

' REQUIRED SUBS/FUNCTIONS:
'   - Err_BadString

Dim strSubName
Dim strPattern As String
Dim strReplace As String
Dim strTemp As String
Dim regEx As New RegExp

On Error GoTo ErrorHandler

strSubName = "strCleanStr"

Call Err_BadString(strSubName, strInput)

' --- End Error Checking ---

' Make the string lower case. Set pattern to find (non-alphanumeric characters)
' and replacement string.
strTemp = LCase(strInput)
strReplace = ""
' This pattern will remove spaces
strPattern = "[^a-z0-9]"
' This pattern will not remove spaces
' strPattern = " \W"
  
' Set regex options
With regEx
    .Global = True
    .MultiLine = True
    .IgnoreCase = True
    .Pattern = strPattern
End With

' Test if there are any special characters. If so, replace them with blanks.
If regEx.Test(strTemp) Then
    strCleanStr = regEx.Replace(strTemp, strReplace)
Else
    strCleanStr = strTemp
End If

Exit Function

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Function


Private Function dPctMatchString(ByRef str1 As String, ByRef str2 As String) As Double
' Returns the % similarity between the two strings. The numerator is the longest number of
' consecutive character matches, starting from the beginning of the string plus the longest
' number of consecutive character matches, starting from the end of the string. The demoninator
' is the larger of the two string lengths.

' REQUIRED SUBS/FUNCTIONS
' - Err_BadString

Dim strSubName
Dim iLen1 As Integer
Dim iLen2 As Integer
Dim iMaxLen As Integer
Dim iMinLen As Integer
Dim i As Integer
Dim j As Integer
Dim k As Integer
Dim iMatchLenFwd As Integer
Dim iMatchLenRev As Integer

On Error GoTo ErrorHandler

strSubName = "dPctMatchString"

Call Err_BadString(strSubName, str1)
Call Err_BadString(strSubName, str2)

' --- End Error Checking ---

' Set lengths of both strings
iLen1 = Len(str1)
iLen2 = Len(str2)
If iLen1 > iLen2 Then
    iMaxLen = iLen1
    iMinLen = iLen2
Else
    iMaxLen = iLen2
    iMinLen = iLen1
End If

' Start at the beginning of the string. Loop through the minimum string length.
' Count the number of consecutive matches.
iMatchLenFwd = 0
i = 1
Do Until i >= iMinLen + 1
    If Left(str1, i) = Left(str2, i) Then
        iMatchLenFwd = i
        i = i + 1
    Else
        i = iMinLen + 1
    End If
Loop

' Start at the end of the string. Loop through the minimum string length minus the characters that were already matched.
' Count the number of consecutive matches
iMatchLenRev = 0
i = 1
Do Until i >= iMinLen + 1 - iMatchLenFwd
    If Right(str1, i) = Right(str2, i) Then
        iMatchLenRev = i
        i = i + 1
    Else
        i = iMinLen + 1
    End If
Loop

dPctMatchString = (iMatchLenFwd + iMatchLenRev) / iMaxLen

Exit Function

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If
    
End Function


Private Function arrGetColumnNum(ByVal arrLookup As Variant, ByVal varString As Variant) As Variant
' Looks in the the first row of an array for a string or array of strings
' and returns and array with the corresponding column numbers. Column numbering starts with 1.
' For 1-D lookup arrays, the function will loop through all of the array elements.
' Only the column number of the first match will be returned.

' REQUIRED SUBS/FUNCTIONS:
'   - iNumOfArrDim
'   - Err_EmptyArray
'   - Err_DimensionCheck
'   - Err_BadString
'   - NormalizeArray

Dim strSubName
Dim idimLookup As Integer
Dim ivarStringType As Integer
Dim i As Long
Dim j As Long
Dim k As Long
Dim n As Long
Dim m As Integer
Dim arrOutput() As Long

On Error GoTo ErrorHandler

strSubName = "GetColumnNum"

Call Err_EmptyArray(strSubName, arrLookup)
Call Err_DimensionCheck(strSubName, arrLookup, 2)

' Test if varString is empty or invalid
If IsArray(varString) = False Then
    If VarType(varString) = vbString Then
        ivarStringType = 0
        Call Err_BadString(strSubName, varString)
    Else
        Err.Raise CustomErrors.CustomErr3
    End If
Else
    ivarStringType = 1
End If

If ivarStringType = 1 Then
    Call Err_EmptyArray(strSubName, varString)
    Call Err_DimensionCheck(strSubName, varString, 1)
End If

' --- End Error Checking ---

' Normalize arrays
Call NormalizeArray(arrLookup)
If ivarStringType = 1 Then Call NormalizeArray(varString)

' Determine number of dimensions in arrLookup
idimLookup = iNumOfArrDim(arrLookup)

Select Case ivarStringType
    Case 0 'Single string
        ' Set arrOutput
        ReDim arrOutput(1 To 1)
        
        ' Check if the arrLookup array has one or two dimensions.
        Select Case idimLookup
            Case 1
                ' Loop through arrLookup
                k = 0
                For i = 1 To UBound(arrLookup)
                    k = k + 1
                    If arrLookup(i) = varString Then
                        arrOutput(1) = k
                        Exit For
                    End If
                Next i
            Case 2
                ' Loop through first row of arrLookup
                k = 0
                For i = 1 To UBound(arrLookup, 2)
                    k = k + 1
                    If arrLookup(1, i) = varString Then
                        arrOutput(1) = k
                        Exit For
                    End If
                Next i
        End Select
        
    Case 1 'String array
        ' Set arrOutput equal to the number of strings to be searched.
        ReDim arrOutput(1 To UBound(varString))

        ' Check if the arrLookup array has one or two dimensions.
        Select Case idimLookup
            Case 1
                ' Loop through varString
                n = 0
                For j = 1 To UBound(varString)
                    n = n + 1
                    ' Loop through arrLookup
                    k = 0
                    For i = 1 To UBound(arrLookup)
                        k = k + 1
                        If arrLookup(i) = varString(j) Then
                            arrOutput(n) = k
                            Exit For
                        End If
                    Next i
                Next j
            Case 2
                ' Loop through varString
                n = 0
                For j = 1 To UBound(varString)
                    n = n + 1
                    ' Loop through first row of arrLookup
                    k = 0
                    For i = 1 To UBound(arrLookup, 2)
                        k = k + 1
                        If arrLookup(1, i) = varString(j) Then
                            arrOutput(n) = k
                            Exit For
                        End If
                    Next i
                Next j
        End Select
End Select

' Return the output array as the function result.
arrGetColumnNum = arrOutput()

Exit Function

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Function


Private Function strSelectSingleFolder(Optional ByVal strTitle As String) As String
' Function that opens a dialog window so that the user can select a single folder.
' The folder's path are returned as a string.

' REQUIRED SUBS/FUNCTIONS:
' - None

Dim strSubName As String
Dim strFolder As String
Dim fdFolder As FileDialog
Dim bSelect As Boolean

On Error GoTo ErrorHandler

' --- End Error Checking ---

strSubName = "strSelectSingleFolder"

Set fdFolder = Application.FileDialog(msoFileDialogFolderPicker)

bSelect = True
With fdFolder
    If strTitle = "" Then
        .Title = "Select a Folder"
    Else
        .Title = strTitle
    End If
    .AllowMultiSelect = False
    If .Show <> -1 Then  ' User has hit the "Cancel" button
        bSelect = False
    Else
        strFolder = .SelectedItems(1)
    End If
End With

Set fdFolder = Nothing

' If user clicked Cancel, go to end
If bSelect = False Then Call Finish

' Return the folder path, with an ending \
If Right(strFolder, 1) <> "\" Then
    strFolder = strFolder & "\"
End If
strSelectSingleFolder = strFolder

Exit Function

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Function


Private Function strSelectSingleFile(Optional ByVal strTitle As String) As String
' Function that opens a dialog window so that the user can select a single file.
' The file's path and file name are returned as a string.

' REQUIRED SUBS/FUNCTIONS:
' - None

Dim strSubName As String
Dim strDefaultPath As String
Dim strFile As String
Dim fdFile As FileDialog
Dim bSelect As Boolean

On Error GoTo ErrorHandler

' --- End Error Checking ---

strSubName = "strSelectSingleFile"

strDefaultPath = ThisWorkbook.Path & "\"

Set fdFile = Application.FileDialog(msoFileDialogFilePicker)

bSelect = True
With fdFile
    .InitialFileName = strDefaultPath
    If strTitle = "" Then
        .Title = "Select a File"
    Else
        .Title = strTitle
    End If
    .AllowMultiSelect = False
    If .Show <> -1 Then  ' User has hit the "Cancel" button
        bSelect = False
    Else
        strFile = .SelectedItems(1)
    End If
End With

Set fdFile = Nothing

' If user clicked Cancel, go to end
If bSelect = False Then Call Finish

' Return the path and file name
strSelectSingleFile = strFile

Exit Function

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Function


Private Function arrSelectMultiFiles(Optional ByVal strTitle As String) As Variant
' Function that opens a dialog window so that the user can select multiple files.
' The path and file names are returned as an array of strings.

' REQUIRED SUBS/FUNCTIONS:
' - None

Dim strSubName As String
Dim strDefaultPath As String
Dim arrFiles As Variant
Dim fdFiles As FileDialog
Dim bSelect As Boolean
Dim i As Long

On Error GoTo ErrorHandler

' --- End Error Checking ---

strSubName = "strSelectMultiFiles"

strDefaultPath = ThisWorkbook.Path & "\"

Set fdFiles = Application.FileDialog(msoFileDialogFilePicker)

bSelect = True
With fdFiles
    .InitialFileName = strDefaultPath
    If strTitle = "" Then
        .Title = "Select the file or files"
    Else
        .Title = strTitle
    End If
    .AllowMultiSelect = True
    If .Show <> -1 Then  ' User has hit the "Cancel" button
        bSelect = False
    Else
    
        ReDim arrFiles(1 To .SelectedItems.Count)
        For i = 1 To .SelectedItems.Count
            arrFiles(i) = .SelectedItems(i)
        Next i
        
    End If
End With

Set fdFiles = Nothing

' If user clicked Cancel, go to end
If bSelect = False Then Call Finish

arrSelectMultiFiles = arrFiles

Exit Function

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Function


Private Function wsCreateWorksheet(ByRef strWsName As String, ByVal bReplace As Boolean) As Worksheet
' Create a worksheet given a worksheet name.
' If bReplace = TRUE, will replace an existing worksheet with the same name.
' If bReplace = FALSE, will add numbers onto the end of of strWsName until a WsName is found
' that isn't already taken.
' If this doesn't work, go to Tools -> References and make sure
' Microsoft VBScript Regular Expressions 5.5 is checked.

' REQUIRED SUBS/FUNCTIONS:
'   - Err_BadString

Dim strSubName As String
Dim wsCurrent As Worksheet
Dim wsNew As Worksheet
Dim str As String
Dim i As Integer
Dim bExists As Boolean
Dim strPattern As String
Dim strReplace As String
Dim strTemp As String
Dim regEx As New RegExp

On Error GoTo ErrorHandler

strSubName = "wsCreateWorksheet"

' Strip invalid characters from name
strPattern = "[*/\?:]|\[|\]"
strReplace = ""
strTemp = strWsName

With regEx
    .Global = True
    .MultiLine = True
    .IgnoreCase = True
    .Pattern = strPattern
End With

If regEx.Test(strTemp) Then
    strWsName = regEx.Replace(strTemp, strReplace)
End If

' Check if name is empty
Call Err_BadString(strSubName, strWsName)

' --- End Error Checking ---

' Save the active sheet
Set wsCurrent = ActiveWorkbook.ActiveSheet

bExists = False
i = 0

' Determine whether a sheet already exists with the same name
On Error Resume Next
Set wsNew = ActiveWorkbook.Sheets(strWsName)
On Error GoTo ErrorHandler

If Not wsNew Is Nothing Then bExists = True

' If a worksheet with the same name exists, delete it or change strWsName (depending on bReplace)
If bExists Then
    If bReplace Then
    
        ' Delete the existing sheet with the same name
        Application.DisplayAlerts = False
        ActiveWorkbook.Sheets(strWsName).Delete
        Application.DisplayAlerts = True

    Else
                
        ' Test if the sheet name + "_1" is taken. If so, test sheet name + "_2", etc.
        ' When a new sheet name is found that is not taken, set that string as the sheet name to be added.
        Do
            i = i + 1
            Select Case i
                Case i < 10
                    str = Left(strWsName, 29) & "_" & i
                Case i < 100
                    str = Left(strWsName, 28) & "_" & i
                Case i < 1000
                    str = Left(strWsName, 27) & "_" & i
                Case Else
                    str = Left(strWsName, 26) & "_" & i
            End Select
                    
            Set wsNew = Nothing
            
            On Error Resume Next
            Set wsNew = ActiveWorkbook.Sheets(str)
            On Error GoTo ErrorHandler
            
        Loop Until wsNew Is Nothing
        
        strWsName = str
    
    End If
 
End If

' Add the sheet
With ActiveWorkbook
    Set wsNew = .Sheets.Add(After:=ActiveWorkbook.Sheets(Sheets.Count))
End With
wsNew.Name = strWsName

' Go back to the original sheet
wsCurrent.Activate

' Set function results
Set wsCreateWorksheet = wsNew

Exit Function

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Function


' ---------------------------------------------------
' Useful Subroutines
' ---------------------------------------------------

Private Sub Pivot_Refresh()

Dim ws As Worksheet
Dim pvt As PivotTable

For Each ws In ThisWorkbook.Worksheets
    For Each pvt In ws.PivotTables
        pvt.RefreshTable
        pvt.Update
    Next pvt
Next ws

End Sub


Private Sub CleanStr(ByRef strInput As String)
' Use regex to remove special charaters from the string.
' Also makes the string all lower case.
' If this doesn't work, go to Tools -> References and make sure
' Microsoft VBScript Regular Expressions 5.5 is checked.

' REQUIRED SUBS/FUNCTIONS:
'   - Err_BadString

Dim strSubName As String
Dim strPattern As String
Dim strReplace As String
Dim strTemp As String
Dim regEx As New RegExp

On Error GoTo ErrorHandler

strSubName = "CleanStr"

Call Err_BadString(strSubName, strInput)

' --- End Error Checking ---

' Make the string lower case. Set pattern to find (non-alphanumeric characters)
' and replacement string.
strTemp = LCase(strInput)
strReplace = ""
strPattern = "[^a-z0-9]"

' Set regex options
With regEx
    .Global = True
    .MultiLine = True
    .IgnoreCase = True
    .Pattern = strPattern
End With

' Test if there are any special characters. If so, take them out (replace them with blanks).
If regEx.Test(strTemp) Then
    strInput = regEx.Replace(strTemp, strReplace)
Else
    strInput = strTemp
End If

Exit Sub

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Sub


Private Sub NormalizeArray(ByRef arrInput)
' Set the LBound of all array dimensions to 1, all indexes and UBounds are adjusted accordingly.
' This works on arrays of up to 5 dimensions.

' REQUIRED SUBS/FUNCTIONS:
'   - iNumOfArrDim
'   - Err_EmptyArray
'   - Err_DimensionCheck

Dim strSubName As String
Dim iDim As Integer
Dim i As Long
Dim i1 As Long
Dim i2 As Long
Dim i3 As Long
Dim i4 As Long
Dim i5 As Long
Dim n1 As Long
Dim n2 As Long
Dim n3 As Long
Dim n4 As Long
Dim n5 As Long
Dim arrBound As Variant
Dim arrTemp As Variant

On Error GoTo ErrorHandler

strSubName = "NormalizeArray"

Call Err_EmptyArray(strSubName, arrInput)
Call Err_DimensionCheck(strSubName, arrInput, 5)

' --- End Error Checking ---

' Find number of dimensions
iDim = iNumOfArrDim(arrInput)

' Loop through all dimensions and store the number of elements
ReDim arrBound(1 To iDim)

For i = 1 To iDim
    arrBound(i) = UBound(arrInput, i) - LBound(arrInput, i) + 1
Next i

' Redim the arrTemp to match the same number of dimensions and elements as arrInput
' Copy the elements from arrInput into arrTemp

Select Case iDim
    Case 1
        ReDim arrTemp(1 To arrBound(1))
        
        n1 = 1
        For i1 = LBound(arrInput) To UBound(arrInput)
            
            arrTemp(n1) = arrInput(i1)
            
            n1 = n1 + 1
        Next i1
        
    Case 2
        ReDim arrTemp(1 To arrBound(1), 1 To arrBound(2))
        
        n1 = 1
        For i1 = LBound(arrInput, 1) To UBound(arrInput, 1)
            
            n2 = 1
            For i2 = LBound(arrInput, 2) To UBound(arrInput, 2)
            
                arrTemp(n1, n2) = arrInput(i1, i2)
                
                n2 = n2 + 1
            Next i2
            
            n1 = n1 + 1
        Next i1
        
    Case 3
        ReDim arrTemp(1 To arrBound(1), 1 To arrBound(2), 1 To arrBound(3))
        
        n1 = 1
        For i1 = LBound(arrInput, 1) To UBound(arrInput, 1)
            
            n2 = 1
            For i2 = LBound(arrInput, 2) To UBound(arrInput, 2)
                
                n3 = 1
                For i3 = LBound(arrInput, 3) To UBound(arrInput, 3)
                
                    arrTemp(n1, n2, n3) = arrInput(i1, i2, i3)
                    
                    n3 = n3 + 1
                Next i3
                
                n2 = n2 + 1
            Next i2
            
            n1 = n1 + 1
        Next i1
        
    Case 4
        ReDim arrTemp(1 To arrBound(1), 1 To arrBound(2), 1 To arrBound(3), 1 To arrBound(4))
        
        n1 = 1
        For i1 = LBound(arrInput, 1) To UBound(arrInput, 1)
            
            n2 = 1
            For i2 = LBound(arrInput, 2) To UBound(arrInput, 2)
                
                n3 = 1
                For i3 = LBound(arrInput, 3) To UBound(arrInput, 3)
                    
                    n4 = 1
                    For i4 = LBound(arrInput, 4) To UBound(arrInput, 4)
                    
                        arrTemp(n1, n2, n3, n4) = arrInput(i1, i2, i3, i4)
                        
                        n4 = n4 + 1
                    Next i4
                    
                    n3 = n3 + 1
                Next i3
                
                n2 = n2 + 1
            Next i2
            
            n1 = n1 + 1
        Next i1
            
    Case 5
        ReDim arrTemp(1 To arrBound(1), 1 To arrBound(2), 1 To arrBound(3), 1 To arrBound(4), 1 To arrBound(5))
        
        n1 = 1
        For i1 = LBound(arrInput, 1) To UBound(arrInput, 1)
            
            n2 = 1
            For i2 = LBound(arrInput, 2) To UBound(arrInput, 2)
                
                n3 = 1
                For i3 = LBound(arrInput, 3) To UBound(arrInput, 3)
                    
                    n4 = 1
                    For i4 = LBound(arrInput, 4) To UBound(arrInput, 4)
                    
                        n5 = 1
                        For i5 = LBound(arrInput, 5) To UBound(arrInput, 5)
                        
                            arrTemp(n1, n2, n3, n4, n5) = arrInput(i1, i2, i3, i4, i5)
                            
                            n5 = n5 + 1
                        Next i5
                        
                        n4 = n4 + 1
                    Next i4
                    
                    n3 = n3 + 1
                Next i3
                
                n2 = n2 + 1
            Next i2
            
            n1 = n1 + 1
        Next i1
                    
End Select

' Redim arrInput
Select Case iDim
    Case 1
        ReDim arrInput(1 To arrBound(1))
    Case 2
        ReDim arrInput(1 To arrBound(1), 1 To arrBound(2))
    Case 3
        ReDim arrInput(1 To arrBound(1), 1 To arrBound(2), 1 To arrBound(3))
    Case 4
        ReDim arrInput(1 To arrBound(1), 1 To arrBound(2), 1 To arrBound(3), 1 To arrBound(4))
    Case 5
        ReDim arrInput(1 To arrBound(1), 1 To arrBound(2), 1 To arrBound(3), 1 To arrBound(4), 1 To arrBound(5))
End Select

' Set arrInput equal to arrTemp
arrInput = arrTemp

Exit Sub

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Sub


Private Sub CompareSortedList(ByVal arrToSearch, ByVal arrToBeSearched, ByRef arrOutput, _
    Optional ByVal bHeaderToSearch As Boolean = False, Optional ByVal bHeaderToBeSearched As Boolean = False)
' Accepts two sorted, 1-D arrays as input. Output is a 1-D array with the same number of elements as
' the arrToSearch array. For each element in the arrToSearch array, find the first instance of that
' element in the arrToBeSearched array and store the index number as the corresponding element in the
' arrOutput array. If the element is not found, a null value is stored.

' If either array has a header, make sure to set the corresponding bHeader to "True"

' REQUIRED SUBS/FUNCTIONS:
'   - iNumOfArrDim
'   - Err_EmptyArray
'   - Err_DimensionCheck
'   - NormalizeArray

Dim n As Long
Dim strSubName As String
Dim i As Long
Dim j As Long
Dim k As Long
Dim iStartSearch As Long
Dim iHeaderAdj As Integer

On Error GoTo ErrorHandler

strSubName = "CompareSortedList"

Call Err_EmptyArray(strSubName, arrToSearch)
Call Err_EmptyArray(strSubName, arrToBeSearched)

Call Err_DimensionCheck(strSubName, arrToSearch, 1)
Call Err_DimensionCheck(strSubName, arrToBeSearched, 1)

' --- End Error Checking ---

' Normalize the two arrays
Call NormalizeArray(arrToSearch)
Call NormalizeArray(arrToBeSearched)

' Dimension arrOutput
ReDim arrOutput(1 To UBound(arrToSearch))

' Adjust for headers
If bHeaderToBeSearched Then
    iStartSearch = 2
Else
    iStartSearch = 1
End If

If bHeaderToSearch Then
    iHeaderAdj = 2
Else
    iHeaderAdj = 1
End If

' Loop through arrToSearch
For j = iHeaderAdj To UBound(arrToSearch)

' Loop through arrToBeSearched and find matches
    For i = iStartSearch To UBound(arrToBeSearched)
        Select Case arrToSearch(j)
            Case Is = arrToBeSearched(i)
' If a match is found, save the index and go to next entry in arrToSearch.
' Start searching on the same row in arrToBeSearched where you left off.

                arrOutput(j) = i
                iStartSearch = i
                Exit For
                
            Case Is < arrToBeSearched(i)
' If a match isn't found and won't be found later in arrToBeSearched (because it is sorted),
' go to the next entry in arrToSearch and start searching where you left off.

                iStartSearch = i
                Exit For
                
            Case Is > arrToBeSearched(i)
' If a match isn't found and could be ound later in arrToBesearched,
' just continue to the next i
        
        End Select
    Next i
Next j

Exit Sub

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Sub


Private Sub ExtractColumn(ByVal arrInput, ByVal iColIndex, ByRef arrOutput, _
    Optional ByVal bSkipFirstRow As Boolean = False)
' Creates a 1-D array from a 2-D array and a specified column number

' REQUIRED SUBS/FUNCTIONS:
'   - iNumOfArrDim
'   - Err_EmptyArray
'   - Err_DimensionCheck
'   - Err_ColIndexHigh
'   - NormalizeArray

Dim strSubName As String
Dim iDim As Integer
Dim m As Long
Dim i As Long
Dim j As Long
Dim iStart As Long

On Error GoTo ErrorHandler

strSubName = "ExtractColumn"

Call Err_EmptyArray(strSubName, arrInput)
Call Err_DimensionCheck(strSubName, arrInput, 2)
Call Err_ColIndexHigh(strSubName, arrInput, iColIndex)

' --- End Error Checking ---

iDim = iNumOfArrDim(arrInput)
Call NormalizeArray(arrInput)

' Dimension arrOutput the same rows as arrInput.

If iDim = 2 Then
' Array has two dimensions.
    
    If bSkipFirstRow Then
        iStart = 2
        ReDim arrOutput(1 To UBound(arrInput, 1) - 1)
    Else
        iStart = 1
        ReDim arrOutput(1 To UBound(arrInput, 1))
    End If
    
    j = 1
    For i = iStart To UBound(arrInput, 1)
        arrOutput(j) = arrInput(i, iColIndex)
        j = j + 1
    Next i
Else
' Array has one dimension. Ignore iColIndex.
    
    If bSkipFirstRow Then
        iStart = 2
        ReDim arrOutput(1 To UBound(arrInput) - 1)
    Else
        iStart = 1
        ReDim arrOutput(1 To UBound(arrInput))
    End If
    
     j = 1
    For i = iStart To UBound(arrInput)
        arrOutput(j) = arrInput(i)
        j = j + 1
    Next i
End If

Exit Sub

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Sub


Private Sub AddArrayIndex(ByRef arrInput As Variant)
' Add another "column" to the array at the end with the current "row" number of each element.
' Will normalize arrInput so that UBound(arrInput, i) = 1 for all i

' REQUIRED SUBS/FUNCTIONS:
'   - iNumOfArrDim
'   - Err_EmptyArray
'   - Err_DimensionCheck
'   - NormalizeArray

Dim strSubName As String
Dim iDim As Integer
Dim m As Long
Dim i As Long
Dim j As Long
Dim arrTemp As Variant

On Error GoTo ErrorHandler

strSubName = "AddArrayIndex"

Call Err_EmptyArray(strSubName, arrInput)
Call Err_DimensionCheck(strSubName, arrInput, 2)

' --- End Error Checking ---

Call NormalizeArray(arrInput)
iDim = iNumOfArrDim(arrInput)

' Dimension arrTemp the same dimensions as arrInput but with another "column."
' Copy data and add indexes to arrTemp.

If iDim = 2 Then
' Array has two dimensions.
    ReDim arrTemp(1 To UBound(arrInput, 1), 1 To UBound(arrInput, 2) + 1)
    For i = 1 To UBound(arrInput, 1)
        For j = 1 To UBound(arrInput, 2)
            arrTemp(i, j) = arrInput(i, j)
            arrTemp(i, UBound(arrInput, 2) + 1) = i
        Next j
    Next i
Else
' Array has one dimension.
    ReDim arrTemp(1 To UBound(arrInput), 1 To 2)
    For i = 1 To UBound(arrInput)
        arrTemp(i, 1) = arrInput(i)
        arrTemp(i, 2) = i
    Next i
End If

' Set arrInput equal to arrTemp
ReDim arrInput(1 To UBound(arrTemp, 1), 1 To UBound(arrTemp, 2))
arrInput = arrTemp

Exit Sub

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Sub


Private Sub UniqueArray(ByRef arrInput As Variant)
' Takes a one-dimensional array and returns the same array (normalized) with a unique list of elements

' REQUIRED SUBS/FUNCTIONS:
'   - iNumOfArrDim
'   - Err_EmptyArray
'   - Err_DimensionCheck
'   - NormalizeArray

Dim strSubName As String
Dim i As Long
Dim j As Long
Dim k As Long
Dim n As Long
Dim bFound As Boolean
Dim bContainsNull As Boolean
Dim arrOutput As Variant

On Error GoTo ErrorHandler

strSubName = "UniqueArray"

Call Err_EmptyArray(strSubName, arrInput)
Call Err_DimensionCheck(strSubName, arrInput, 1)

' --- End Error Checking ---

Call NormalizeArray(arrInput)

' Dimension the Output array
ReDim arrOutput(1 To UBound(arrInput))

bContainsNull = False

' Loop through the Input array.
k = 1
For i = 1 To UBound(arrInput)
    bFound = False

' Check whether input array contains a null entry.
    If IsEmpty(arrInput(i)) Then bContainsNull = True

' Test whether the Input array element is already present in the Output array.
    For j = 1 To UBound(arrOutput)
        If arrInput(i) = arrOutput(j) Then
            bFound = True
            Exit For
        End If
    Next j
    
' If not, add to the Output array
    If bFound = False Then
        arrOutput(k) = arrInput(i)
        k = k + 1
    End If
Next i

' Redimension the Output array to remove blank elements,
' except for 1 instance of a blank element if it's in arrInput.
If bContainsNull = True Then
    ReDim Preserve arrOutput(1 To k)
Else
    ReDim Preserve arrOutput(1 To k - 1)
End If

' Turn the Output array back into the Input array
ReDim arrInput(1 To UBound(arrOutput))

For i = 1 To UBound(arrOutput)
    arrInput(i) = arrOutput(i)
Next i

Exit Sub

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Sub


Private Sub SortArray(ByRef arrInput As Variant, ByVal iColIndex As Long, Optional ByVal bHeader As Boolean = False)
' Uses worksheet sort to sort an array on a specified column number. Assumes that the first column is number 1.
' NOTE: This sub will change the sorted array lower bounds to 1, if they were previously 0
' NOTE: This sub will also change a 2-D array with only 1 column into a 1-D array

' REQUIRED SUBS/FUNCTIONS:
'   - iNumOfArrDim
'   - Err_EmptyArray
'   - Err_DimensionCheck
'   - Err_ColIndexHigh
'   - NormalizeArray
'   - PasteArrayToRange
'   - CopyRangeToArray

Dim strSubName As String
Dim i As Long
Dim m As Long
Dim rng As Range
Dim wsSort As Worksheet

On Error GoTo ErrorHandler

strSubName = "SortArray"

Call Err_EmptyArray(strSubName, arrInput)
Call Err_DimensionCheck(strSubName, arrInput, 2)
Call Err_ColIndexHigh(strSubName, arrInput, iColIndex)

' --- End Error Checking ---

Call NormalizeArray(arrInput)

' Create a worksheet
Set wsSort = ActiveWorkbook.Sheets.Add(After:=ActiveWorkbook.Sheets(Sheets.Count))
Set rng = wsSort.Range("a1")

' Paste the array
Call PasteArrayToRange(rng, arrInput)

' Sort the array
If bHeader = False Then
    With wsSort.Sort
        .SortFields.Clear
        .SortFields.Add Key:=rng.Cells(1, iColIndex), SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
        .SetRange rng
        .Header = xlNo
        .MatchCase = False
        .Orientation = xlTopToBottom
        .Apply
    End With
Else
    With wsSort.Sort
        .SortFields.Clear
        .SortFields.Add Key:=rng.Cells(1, iColIndex), SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal
        .SetRange rng
        .Header = xlYes
        .MatchCase = False
        .Orientation = xlTopToBottom
        .Apply
    End With
End If

' Copy the sorted range back to an array
Call CopyRangeToArray(rng, arrInput)

' Delete the sheet created for sorting
Application.DisplayAlerts = False
wsSort.Delete
Application.DisplayAlerts = True

Exit Sub

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    ' Delete any temporary sheets used for sorting
    On Error Resume Next
    
    Application.DisplayAlerts = False
    wsSort.Delete
    Application.DisplayAlerts = True
    
    On Error GoTo 0
    
    Call Finish
End If

End Sub


Private Sub CopyRangeToArray(ByVal rngInput As Range, ByRef arrInput As Variant)
' Load data from a range into an array. If it's one column of data, a 1-D array will be created. If more than
' one column, a 2-D array will be created.

' REQUIRED SUBS/FUNCTIONS:
'   - Err_InvalidRange

Dim strSubName As String
Dim iLastCol As Integer
Dim iLastRow As Long
Dim arrTemp As Variant
Dim i As Long

On Error GoTo ErrorHandler

strSubName = "CopyRangeToArray"

Call Err_InvalidRange(strSubName, rngInput)

' --- End Error Checking ---

' Find how big the range is
iLastCol = rngInput.Columns.Count
iLastRow = rngInput.Rows.Count

' Copy the range to the temporary array
arrTemp = rngInput

If iLastCol = 1 Then
    If iLastRow = 1 Then
' If there is only one column and one row, arrTemp is a variable, not an array.
        ReDim arrInput(1 To 1) As String
        arrInput(1) = arrTemp
    Else
' If there is only one column and multiple rows, change arrTemp to a one-dimensional array.
        ReDim arrInput(1 To UBound(arrTemp, 1)) As String
        For i = 1 To UBound(arrTemp, 1)
            arrInput(i) = arrTemp(i, 1)
        Next i
    End If
Else
' If there are more than one columns, copy the temporary array as is to the output array
    ReDim arrInput(1 To UBound(arrTemp, 1), 1 To UBound(arrTemp, 2)) As String
    arrInput = arrTemp
End If

Exit Sub

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Sub


Private Sub PasteArrayToRange(ByRef rngInput As Range, ByVal arrInput As Variant)
' Paste all data from an array to a range.

' Assumes all data are strings, including numeric data. To have numeric data treated as numbers,
' comment out the [rng.NumberFormat = "@"] statements below.

' REQUIRED SUBS/FUNCTIONS:
'   - iNumOfArrDim
'   - Err_EmptyArray
'   - Err_DimensionCheck

Dim strSubName As String
Dim iDim As Integer
Dim i As Long
Dim m As Long
Dim rngTemp As Range

On Error GoTo ErrorHandler

strSubName = "PasteArrayToRange"

Call Err_EmptyArray(strSubName, arrInput)
Call Err_DimensionCheck(strSubName, arrInput, 2)

' --- End Error Checking ---

iDim = iNumOfArrDim(arrInput)

' Resize the range to match the data from the array
Set rngTemp = rngInput.Cells(1, 1)

' Check if array has one or two dimensions.
' Resize the range to match the array size.
' Paste the array to the range.
If iDim = 2 Then
    Set rngInput = rngTemp.Resize(UBound(arrInput, 1) - LBound(arrInput, 1) + 1, UBound(arrInput, 2) - LBound(arrInput, 2) + 1)
    
    ' If you need to paste numbers as numbers, comment this out:
    rngInput.NumberFormat = "@"
    
    rngInput = arrInput
Else
    Set rngInput = rngTemp.Resize(UBound(arrInput) - LBound(arrInput) + 1, 1)
        
    ' If you need to paste numbers as numbers, comment this out:
    rngInput.NumberFormat = "@"

    rngInput = Application.Transpose(arrInput)
End If

Exit Sub

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Sub


Private Sub CreateWorksheet(ByRef strWsName As String, ByVal bReplace As Boolean)
' Create a worksheet given a worksheet name.
' If bReplace = TRUE, will replace an existing worksheet with the same name.
' If bReplace = FALSE, will add numbers onto the end of of strWsName until a WsName is found
' that isn't already taken.
' If this doesn't work, go to Tools -> References and make sure
' Microsoft VBScript Regular Expressions 5.5 is checked.

' REQUIRED SUBS/FUNCTIONS:
'   - Err_BadString

Dim strSubName As String
Dim wsCurrent As Worksheet
Dim wsNew As Worksheet
Dim str As String
Dim i As Integer
Dim bExists As Boolean
Dim strPattern As String
Dim strReplace As String
Dim strTemp As String
Dim regEx As New RegExp


On Error GoTo ErrorHandler

strSubName = "CreateWorksheet"

' Strip invalid characters from name
strPattern = "[*/\?:]|\[|\]"
strReplace = ""
strTemp = strWsName

With regEx
    .Global = True
    .MultiLine = True
    .IgnoreCase = True
    .Pattern = strPattern
End With

If regEx.Test(strTemp) Then
    strWsName = regEx.Replace(strTemp, strReplace)
End If

' Check if name is empty
Call Err_BadString(strSubName, strWsName)

' --- End Error Checking ---

' Save the active sheet
Set wsCurrent = ActiveWorkbook.ActiveSheet

bExists = False
i = 0

' Determine whether a sheet already exists with the same name
On Error Resume Next
Set wsNew = ActiveWorkbook.Sheets(strWsName)
On Error GoTo ErrorHandler

If Not wsNew Is Nothing Then bExists = True

' If a worksheet with the same name exists, delete it or change strWsName (depending on bReplace)
If bExists Then
    If bReplace Then
    
        ' Delete the existing sheet with the same name
        Application.DisplayAlerts = False
        ActiveWorkbook.Sheets(strWsName).Delete
        Application.DisplayAlerts = True

    Else
                
        ' Test if the sheet name + "_1" is taken. If so, test sheet name + "_2", etc.
        ' When a new sheet name is found that is not taken, set that string as the sheet name to be added.
        Do
            i = i + 1
            Select Case i
                Case i < 10
                    str = Left(strWsName, 29) & "_" & i
                Case i < 100
                    str = Left(strWsName, 28) & "_" & i
                Case i < 1000
                    str = Left(strWsName, 27) & "_" & i
                Case Else
                    str = Left(strWsName, 26) & "_" & i
            End Select
                    
            Set wsNew = Nothing
            
            On Error Resume Next
            Set wsNew = ActiveWorkbook.Sheets(str)
            On Error GoTo ErrorHandler
            
        Loop Until wsNew Is Nothing
        
        strWsName = str
    
    End If
 
End If

' Add the sheet
With ActiveWorkbook
    Set wsNew = .Sheets.Add(After:=ActiveWorkbook.Sheets(Sheets.Count))
End With
wsNew.Name = strWsName

' Re-activate the original active sheet
wsCurrent.Activate

Exit Sub

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Sub


Private Sub TransposeArray(ByRef arrInput As Variant)
' Transpose the input 1-D or 2-D array

' REQUIRED SUBS/FUNCTIONS:
'   - iNumOfArrDim
'   - Err_EmptyArray
'   - Err_DimensionCheck
'   - NormalizeArray

Dim strSubName As String
Dim iDim As Integer
Dim arrTemp As Variant
Dim i As Long
Dim j As Long

On Error GoTo ErrorHandler

strSubName = "TransposeArray"

Call Err_EmptyArray(strSubName, arrInput)
Call Err_DimensionCheck(strSubName, arrInput, 2)

' --- End Error Checking ---

iDim = iNumOfArrDim(arrInput)
Call NormalizeArray(arrInput)

If iDim = 2 Then
' Array has two dimensions.

    ' Dimension arrTemp
    ReDim arrTemp(1 To UBound(arrInput, 2), 1 To UBound(arrInput, 1))
    
    ' Loop through each element of arrInput and save to arrTemp
    For i = 1 To UBound(arrInput, 1)
        For j = 1 To UBound(arrInput, 2)
            arrTemp(j, i) = arrInput(i, j)
        Next j
    Next i
    
    ' Replace arrInput with arrTemp
    ReDim arrInput(1 To UBound(arrTemp, 1), 1 To UBound(arrTemp, 2))
    arrInput = arrTemp

Else
' Array has one dimension.

    ' Dimension arrTemp
    ReDim arrTemp(1 To 1, 1 To UBound(arrInput))
    
    ' Loop through each element of arrInput and save to arrTemp
    For i = 1 To UBound(arrInput)
        arrTemp(1, i) = arrInput(i)
    Next i
    
    ' Replace arrInput with arrTemp
    ReDim arrInput(1 To 1, 1 To UBound(arrTemp, 2))
    arrInput = arrTemp

End If

Exit Sub

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Sub


Private Sub ConnectToSQLServer(ByVal strServer As String, ByVal strDB As String, _
    ByVal strQuery As String, ByRef arrOutput As Variant, ByRef arrFieldNames As Variant, _
    Optional ByVal bColIndexFirst As Boolean = False)
' Get data from a SQL Server database. If this doesn't work, go to Tools --> References
' and check "Microsoft ActiveX Data Objects 2.8."
' Data will be output to a 2-D array. By default, the first index of the array is the row number
' and the second index is the column number.

' REQUIRED SUBS/FUNCTIONS:
' - Err_BadString
' - TransposeArray
' - bEmptyArray

Dim strSubName As String
Dim con As ADODB.Connection
Dim cmd As ADODB.Command
Dim rs As ADODB.Recordset
Dim i As Long
 
On Error GoTo ErrorHandler

strSubName = "ConnectToSQLServer"

Call Err_BadString(strSubName, strServer)
Call Err_BadString(strSubName, strDB)
Call Err_BadString(strSubName, strQuery)

' --- End Error Checking ---

' Set variables
Set con = New ADODB.Connection
Set cmd = New ADODB.Command
Set rs = New ADODB.Recordset

' Open connection
con.Open "Provider=SQLOLEDB;" & _
    "Data Source=" & strServer & ";" & _
    "Initial Catalog=" & strDB & ";" & _
    "Integrated Security=SSPI;"

' Set command to execute query. Timeout set to 10 minutes.
cmd.ActiveConnection = con
cmd.CommandText = strQuery
cmd.CommandTimeout = 600

Set rs = cmd.Execute

' If output is not blank, save query output and field names to arrays
ReDim arrFieldNames(1 To rs.Fields.Count)

If rs.EOF = False Then
    arrOutput = rs.GetRows
    For i = 1 To rs.Fields.Count
        arrFieldNames(i) = rs.Fields(i - 1).Name
    Next i
End If

If bColIndexFirst = False Then
    If bEmptyArray(arrOutput) = False Then
        Call TransposeArray(arrOutput)
    End If
End If

Exit Sub

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Sub


Private Sub ConnectToAccessDB(ByVal strFileLocation As String, ByVal strQuery As String, _
    ByRef arrOutput As Variant, ByRef arrFieldNames As Variant, _
    Optional ByVal bColIndexFirst As Boolean = False)
' Get data from an Access database file. If this doesn't work, go to Tools --> References
' and check "Microsoft Office 14.0 Object Library."
' Data will be output to a 2-D array. By default, the first index of the array is the row number
' and the second index is the column number.

' REQUIRED SUBS
' - Err_BadString
' - TransposeArray
' - bEmptyArray

Dim strSubName As String
Dim con As ADODB.Connection
Dim cmd As ADODB.Command
Dim rs As ADODB.Recordset
Dim i As Long
 
On Error GoTo ErrorHandler

strSubName = "ConnectToAccessDB"

Call Err_BadString(strSubName, strFileLocation)
Call Err_BadString(strSubName, strQuery)

' --- End Error Checking ---

' Set variables
Set con = New ADODB.Connection
Set cmd = New ADODB.Command
Set rs = New ADODB.Recordset

' Open connection
con.Open "Provider=Microsoft.ACE.OLEDB.12.0;" & _
    "Data Source=" & strFileLocation

' Set command to execute query. Timeout set to 10 minutes.
cmd.ActiveConnection = con
cmd.CommandText = strQuery
cmd.CommandTimeout = 600

Set rs = cmd.Execute

' If output is not blank, save query output to array
ReDim arrFieldNames(1 To rs.Fields.Count)

If rs.EOF = False Then
    arrOutput = rs.GetRows
    For i = 1 To rs.Fields.Count
        arrFieldNames(i) = rs.Fields(i - 1).Name
    Next i
End If

If bColIndexFirst = False Then
    If bEmptyArray(arrOutput) = False Then
        Call TransposeArray(arrOutput)
    End If
End If

Exit Sub

ErrorHandler:

If bCentralErrorHandler(strSubName) Then
' If debug mode turned on then break execution.
    Stop
    Resume ' Resume code execution at the same line that caused the error
Else
    Call Finish
End If

End Sub


